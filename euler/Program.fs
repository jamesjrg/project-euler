(*
problem 1

If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below 1000.
*)

//first version

let sum list =
    let rec accf list acc =
        match list with
        | [] -> acc
        | h :: t -> accf t (acc + h)
    accf list 0

let divisible_by_3_or_5 x = if x % 3 = 0 || x % 5 = 0 then true else false

let problem1 = sum [for x in [1..999] do if divisible_by_3_or_5 x then yield x]

// second version

let problem1_v2 = 
    let rec accf prev acc =
        match prev + 1 with
        | curr when curr > 999 -> acc
        | curr when curr % 3 = 0 || curr % 5 = 0 -> accf curr (acc + curr)
        | curr -> accf curr acc
    accf 1 0

(*
problem 2
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
*)

let problem2 = 
    let rec accf prev_prev prev acc =
        match prev_prev + prev with
        | curr when curr > 4000000 -> acc
        | curr when curr % 2 = 0 -> accf prev curr (acc + curr)
        | curr -> accf prev curr acc
    accf 1 2 2

(*
problem 3
The prime factors of 13195 are 5, 7, 13 and 29.

What is the largest prime factor of the number 600851475143 ?
*)

let problem3_number = 600851475143UL

let rec try_find_first_true start (arr : bool []) = 
    match start with
    | start when start >= arr.Length -> None
    | start -> if arr.[start] then Some(start) else try_find_first_true (start + 1) arr

let print_array_filtered arr = 
    Array.iteri(fun i x -> if x then printf "%i, " i) arr

let problem3_number_sqrt = int (sqrt (double problem3_number))

//simplistic version of sieve of Eratosthenes, other methods too complex
//use imperative style to avoid creating lots of new lists
//array is 0 indexed, but to keep things simple equate index to actual number, so position 0 represents number 0
let primes : bool array = 
    let primes = Array.create (problem3_number_sqrt + 1) true
    let mutable i = 2
    while i <= problem3_number_sqrt do
        for j = 2 to problem3_number_sqrt / i do
            primes.[i*j] <- false
        let res = try_find_first_true (i + 1) primes
        match res with
        | Some x -> i <- x
        | None -> i <- problem3_number_sqrt + 1
    //print_array_filtered primes
    primes

let is_factor x = if problem3_number % x = 0UL then true else false
(*
// assuming problem3_number itself is not prime
let problem3 =
    let rec recf prev =
        match prev - 1UL with
        | curr when is_factor curr && is_prime curr -> curr
        | curr -> recf curr
    recf (uint64 (sqrt (double problem3_number)))
    
    *)