//util/debug 

//from problem 3
let print_array_filtered arr = 
    Array.iteri(fun i x -> if x then printf "%i, " i) arr

(*
problem 1

If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below 1000.
*)

//first version, without using library sum function for some practice with recursion

let problem1 =
    let sum list =    
        let rec accf list acc =
            match list with
            | [] -> acc
            | h :: t -> accf t (acc + h)
        accf list 0

    let divisible_by_3_or_5 x = if x % 3 = 0 || x % 5 = 0 then true else false

    sum [for x in [1..999] do if divisible_by_3_or_5 x then yield x]

// second version

let problem1_v2 = List.sum[for x in [1..999] do if x % 3 = 0 || x % 5 = 0 then yield x]

(*
problem 2

Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
*)

let problem2 =
    let rec accf prev_prev prev acc =
        match prev_prev + prev with
        | curr when curr > 4000000 -> acc
        | curr when curr % 2 = 0 -> accf prev curr (acc + curr)
        | curr -> accf prev curr acc
    accf 1 2 2

(*
problem 3

The prime factors of 13195 are 5, 7, 13 and 29.

What is the largest prime factor of the number 600851475143 ?
*)

let problem3 =
    let problem3_number = 600851475143UL
    
    //not being able to store the iterator from the last search and continuing from there is annoying, maybe there is a better way of doing this
    let rec try_find_first_true start (arr : bool []) = 
        match start with
        | start when start >= arr.Length -> None
        | start -> if arr.[start] then Some(start) else try_find_first_true (start + 1) arr

    //simplistic version of sieve of Eratosthenes, other options include both variations on sieves and variations on trial and error
    //use imperative style to avoid creating lots of new lists
    //array is 0 indexed, but to keep things simple equate index to actual number, so position 0 represents number 0
    //perhaps should just have made a list of numbers rather than a list of bools, saves a little memory but makes code more confusing and means indexes have to be cast to uint64 later on
    let problem3_number_sqrt = int (sqrt (double problem3_number))
    let primes : bool array = 
        let primes = Array.create (problem3_number_sqrt + 1) true
        let mutable i = 2
        while i <= problem3_number_sqrt do
            for j = 2 to problem3_number_sqrt / i do
                primes.[i*j] <- false
            let res = try_find_first_true (i + 1) primes
            match res with
            | Some x -> i <- x
            | None -> i <- problem3_number_sqrt + 1
        primes

    let is_factor x = if problem3_number % x = 0UL then true else false

    let rec recfunc curr =
        //could have used reverse rather than revursive indexing from end, would perhaps mean memory but faster
        if primes.[curr] && is_factor (uint64 curr)
            then Some(curr)
        elif curr - 1 < 0 then None
        else recfunc (curr - 1)

    recfunc (primes.Length - 1)

(*
problem 4

A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.

Find the largest palindrome made from the product of two 3-digit numbers.
*)
let problem4 =
    let is_palindrome n =
        match n with
        | n when n > 99999 -> 
            let ch_arr = (string n).ToCharArray()
            if ch_arr.[0..2] = (Array.rev ch_arr).[0..2] then true else false
        //not catering for case where it isn't a 6 digit number
        | n -> false

    let rec rfunc_outer x =  
        let rec rfunc_inner x y =
            let curr = x * y
            match is_palindrome curr with
            | true -> Some (curr, x, y)
            | false ->
                if y < x then
                    None 
                else
                    let y = y - 1
                    rfunc_inner x y
        let res = rfunc_inner x 999
        match res with
        | Some details -> Some details
        | None ->
            if x < 100 then
                None
            else
                let x = x - 1
                rfunc_outer x
    rfunc_outer 999
       
        

