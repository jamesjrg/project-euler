(*
problem 1

If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below 1000.
*)

//first version, without using library sum function for some practice with recursion

let problem1 =
    let sum list =    
        let rec accf list acc =
            match list with
            | [] -> acc
            | h :: t -> accf t (acc + h)
        accf list 0

    let divisible_by_3_or_5 x = if x % 3 = 0 || x % 5 = 0 then true else false

    sum [for x in [1..999] do if divisible_by_3_or_5 x then yield x]

// second version

let problem1_v2 = List.sum[for x in [1..999] do if x % 3 = 0 || x % 5 = 0 then yield x]

(*
problem 2

Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
*)

let problem2 =
    let rec accf prev_prev prev acc =
        match prev_prev + prev with
        | curr when curr > 4000000 -> acc
        | curr when curr % 2 = 0 -> accf prev curr (acc + curr)
        | curr -> accf prev curr acc
    accf 1 2 2

(*
problem 3

The prime factors of 13195 are 5, 7, 13 and 29.

What is the largest prime factor of the number 600851475143 ?
*)
let problem3 =
    let problem3_number = 600851475143UL
    
    //not being able to store the iterator from the last search and continuing from there is annoying, maybe there is a better way of doing this
    let rec try_find_first_true start (arr : bool []) = 
        match start with
        | start when start >= arr.Length -> None
        | start -> if arr.[start] then Some(start) else try_find_first_true (start + 1) arr

    //simplistic version of sieve of Eratosthenes, other options include both variations on sieves and variations on trial and error
    //use imperative style to avoid creating lots of new lists
    //array is 0 indexed, but to keep things simple equate index to actual number, so position 0 represents number 0
    //perhaps should just have made a list of numbers rather than a list of bools, saves a little memory but makes code more confusing and means indexes have to be cast to uint64 later on
    let problem3_number_sqrt = int (sqrt (double problem3_number))
    let primes : bool array = 
        let primes = Array.create (problem3_number_sqrt + 1) true
        let mutable i = 2
        while i <= problem3_number_sqrt do
            for j = 2 to problem3_number_sqrt / i do
                primes.[i*j] <- false
            let res = try_find_first_true (i + 1) primes
            match res with
            | Some x -> i <- x
            | None -> i <- problem3_number_sqrt + 1
        primes

    let is_factor x = if problem3_number % x = 0UL then true else false

    let rec recfunc curr =
        //could have used reverse rather than revursive indexing from end, would perhaps mean memory but faster
        if primes.[curr] && is_factor (uint64 curr)
            then Some(curr)
        elif curr - 1 < 0 then None
        else recfunc (curr - 1)

    recfunc (primes.Length - 1)

(* problem 4

A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.

Find the largest palindrome made from the product of two 3-digit numbers.
*)
let is_palindrome n =
    let ch_arr = (string n).ToCharArray()
    if ch_arr = (Array.rev ch_arr) then true else false

let problem4_v1 =
    //this version does the multiplication twice
    List.max([for x in [100..999] do for y in [100..999] do if is_palindrome (x*y) then yield (x*y)])
let problem4_v2 =
    //this version needs two steps to create the list
    List.max (List.filter (fun item -> is_palindrome item) [for x in [100..999] do for y in [100..999] -> x*y])

(* problem 5

2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.

What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
*)

//exclude numbers which are themselves factors of other numbers, also 1..19 because we only check every 20th number
let dividers = [for x in [1..19] do if [for y in [(x + 1)..19] do if y % x = 0 then yield y].Length = 0 then yield x]

let problem5 =
    let rec rec_func x =
        let rec inner_rec_func x (remaining : int list) =
            match remaining with
            | [] -> true
            | h :: t ->
                if x % h <> 0 then false else inner_rec_func x t
        if inner_rec_func x dividers then x
        else rec_func (x + 20)
    rec_func 20

